# 实验2

姓名: 黄嘉敏
学号: 520021911392

> 1. 请思考多级页表相比单级页表带来的优势和劣势（如果有的话），并计算在 AArch64 页表中分别以 4KB 粒度和 2MB 粒度映射 0～4GB 地址范围所需的物理内存大小（或页表页数量）。

优势：多级页表能够在表示较大范围的虚拟地址时候，所占用的空间更少，因为他有些页表项在第一级就是INVALID，不必有第二级页表，而单级页表则会占据更多空间。
劣势：设计较为复杂。
计算： 4KB粒度，l3页表有2^{11}个，l2页表有2^{2}个，l1,l0页表有1个，共有2054个页表。物理内存占用为=约为8MB。
       2MB粒度，页偏移21位，l2页表4个，l1,l0有1个，共有5个页表，物理内存占用为5*4KB = 20KB
    

> 3. 请思考在 init_boot_pt 函数中为什么还要为低地址配置页表，并尝试验证自己的解释。
由于ARM架构中使用的是48位的地址,因此会分为低地址页表和高地址页表两段,并且在开启mmu的时候，执行的是init段的代码，也就是低地址代码，此时PC指向低地址，由于此时就PC需要使用虚拟地址，因此需要配置低地址的页表从而使得init段能够正常运行。
验证：去掉低地址页表后，低地址代码无法运行，直接卡死。

> 4. 请解释 ttbr0_el1 与 ttbr1_el1 是具体如何被配置的，给出代码位置，并思考页表基地址配置后为何需要ISB指令。
代码位于`/kernel/arch/aarch64/boot/raspi3/init/tools.S`中，在这里将页表的物理地址写入了`ttbr0_el1`和`ttbr1_el1`,代码如下：
```
	adrp    x8, boot_ttbr0_l0
	msr     ttbr0_el1, x8
	adrp    x8, boot_ttbr1_l0
	msr     ttbr1_el1, x8
	isb
```
isb指令是为了保证ISB指令之后的指令都从指令高速缓存或内存中重新预取，这样做的目的是为了让cpu不因乱序执行优化而导致ttbr0，ttbr1的值没有更新为基地址。

> 8. 阅读 Arm Architecture Reference Manual，思考要在操作系统中支持写时拷贝（Copy-on-Write，CoW）[^cow]需要配置页表描述符的哪个/哪些字段，并在发生缺页异常（实际上是 permission fault）时如何处理。
  配置是否可写的权限位字段。写时拷贝允许应用程序A和B以只读的方式共享同一段物理内存，一旦某个应用程序对该内存区域进行修改就会触发缺页异常。之后 CPU 会将控制流传递给操作系统预先设置的缺页异常处理函数，在该函数中，操作系统发现当前的缺页异常是由于应用程序写了只读内存，而且相应的内存区域又是被操作系统标记成写时拷贝的。操作系统会在物理内存中将缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以可读可写的方式重新映射给触发异常的应用程序，此后再恢复应用程序的执行。

> 9. 为了简单起见，在 ChCore 实验中没有为内核页表使用细粒度的映射，而是直接沿用了启动时的粗粒度页表，请思考这样做有什么问题。
这导致了内部空间碎片，空间浪费的情况。同时内核可能会分配一些大小较小但有不同权限的内存片段，粗粒度页表不容易对权限做细粒度管理。